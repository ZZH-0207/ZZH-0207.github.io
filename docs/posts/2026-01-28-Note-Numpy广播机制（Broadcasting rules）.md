### 概念介绍
**广播**（broadcasting）这一术语描述了 NumPy 在执行算术运算时，如何处理形状不同的数组。
%% 注：广播机制只适用于所有逐元素的操作，不适用于线性代数运算 %%

- 机制一：如果两个数组维数不同，则"小"数组将会被延展至与"大"数组相同的维数
- 机制二：如果两个数组维数相同但是某一个维度的大小为1，则数组间的**算术操作**操作将会视其为最大的

举一个最简单的例子：
``` Python
a = np.array([1,2,3,4])
b = np.int64(2)

a.ndim  # 1
b.ndim  # 0

a+b
# array([3, 4, 5, 6])
```
可以理解成数组`b`被延展为`array([2,2,2,2])`，但要注意，代码并没有真正地在内存中创建数组`array([2,2,2,2])`，也就是说没有产生额外的内存开销。


复杂例子(批量计算多个样本到多个中心点的距离)：

``` Python
import numpy as np
rg = np.random.default_rng(seed=1)

# 创建维度为5×2的矩阵，代表5个样本点，每行代表一个样本点的向量
samples = rg.random((5,2))
# array([[0.51182162, 0.9504637 ],
#        [0.14415961, 0.94864945],
#        [0.31183145, 0.42332645],
#        [0.82770259, 0.40919914],
#        [0.54959369, 0.02755911]])

# 创建10个中心点，每个中心点是一个2维向量
centers = rg.random((10,1,2))
# array([[[0.75351311, 0.53814331]],
#        [[0.32973172, 0.7884287 ]],
#        [[0.30319483, 0.45349789]],
#        [[0.1340417 , 0.40311299]],
#        [[0.20345524, 0.26231334]],
#        [[0.75036467, 0.28040876]],
#        [[0.48519097, 0.9807372 ]],
#        [[0.96165719, 0.72478994]],
#        [[0.54122686, 0.2768912 ]],
#        [[0.16065201, 0.96992541]]])


# 这一步发生了广播机制！！！
diff = centers - samples
# array([[[ 0.24169148, -0.41232038],
#         [ 0.6093535 , -0.41050613],
#         [ 0.44168166,  0.11481686],
#         [-0.07418949,  0.12894418],
#         [ 0.20391942,  0.5105842 ]],

# ......

#        [[ 0.02940523, -0.67357249],
#         [ 0.39706724, -0.67175824],
#         [ 0.2293954 , -0.14643524],
#         [-0.28647574, -0.13230793],
#         [-0.00836683,  0.24933209]],

#        [[-0.35116962,  0.01946172],
#         [ 0.0164924 ,  0.02127597],
#         [-0.15117944,  0.54659896],
#         [-0.66705059,  0.56072628],
#         [-0.38894168,  0.9423663 ]]])
# 生成了一个10×5×2的矩阵，代表每个样本点到每个中心点的向量差

# 这一步计算每个样本点到每个中心点的距离的平方
diff2 = np.sum(diff**2, axis=2)

# 开方
Sqrt = np.sqrt(diff2)
# array([[0.47793605, 0.73472918, 0.45636126, 0.14876384, 0.54979938],
#        [0.24374592, 0.2451687 , 0.3655408 , 0.62593135, 0.79199862],
#        [0.53898066, 0.52006467, 0.03138323, 0.52637513, 0.49207341],
#        [0.66506426, 0.54563028, 0.17893513, 0.6936876 , 0.56011085],
#        [0.75408271, 0.68889275, 0.19408922, 0.64129572, 0.41823602],
#        [0.71124989, 0.90223622, 0.46123405, 0.15022688, 0.32286519],
#        [0.04031968, 0.34253761, 0.58374675, 0.66631071, 0.95535134],
#        [0.50326999, 0.84759387, 0.71634749, 0.3428431 , 0.8098933 ],
#        [0.67421404, 0.78033424, 0.27214983, 0.31555307, 0.24947243],
#        [0.35170848, 0.02691962, 0.56712049, 0.87141864, 1.01947529]])
# 代表每个样本点到每个中心点的距离,元素[0,0]代表第一个样本点到第一个中心点的距离,依次类推

np.argmin(Sqrt, axis=1)
# array([3, 0, 2, 2, 2, 3, 0, 3, 4, 1])
# 代表每个样本点距离最近的中心点的索引,元素[0]代表第一个样本点距离最近的中心点的索引,依次类推
```
